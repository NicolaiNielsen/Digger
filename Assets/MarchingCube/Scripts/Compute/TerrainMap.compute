#pragma kernel CSMain //This is the function that should be run using dispatch
#include "/Includes/Noise.compute"


//data structure 3d grid of desnitivy values
//(0,0,0) = 0,5
//(0,0,1) = 0,52

RWTexture3D<float> DensityTexture;
//Note sure i fully understand

int textureSize;
//float planetSize;
float sizeX;
float sizeY;
float sizeZ;
float noiseScale;
float noiseHeightMultiplier;

float fbm(int numLayers, float lacunarity, float persistence, float scale, float3 pos) {
	float noise = 0;
	float frequency = scale / 100;
	float amplitude = 1;

	for (int i = 0; i < numLayers; i ++) {
		float n = 1-abs(snoise(pos * frequency)*2-1);
		//n*=n;
		noise += n * amplitude;

		amplitude *= persistence;
		frequency *= lacunarity;
	}

	return noise;
}

float calculateDensity(int3 cell) {
    float3 worldPos = float3(
    (cell.x / (textureSize - 1.0) - 0.5f) * sizeX,
    (cell.y / (textureSize - 1.0) - 0.5f) * sizeY,
    (cell.z / (textureSize - 1.0) - 0.5f) * sizeZ
);

    // Set the height of the ground (0 = middle, negative = lower, positive = higher)
    float surfaceHeight = 0;

    // Flat ground: below the surface is solid, above is air
    float density = worldPos.y - surfaceHeight;

    // Add bumps/hills with noise
    float noise = fbm(6, 2, 0.5, noiseScale, worldPos) * noiseHeightMultiplier;
    density += noise;

    return density;
}

[numthreads(8,8,8)]
void CSMain (int3 id : SV_DispatchThreadID)
{
	if (id.x >= textureSize || id.y >= textureSize || id.z >= textureSize) {
		return;
	}

	float density = 0;

	const int b = 1;
	if (id.x >= textureSize-b || id.y >= textureSize-b || id.z >= textureSize-b) {
		density = 1;
	}
	else if (id.x <= b || id.y <= b || id.z <=b) {
		density = 1;
	}
	else {
		density = calculateDensity(id);
	}

	DensityTexture[id] = density;
}
